# Разработка фреймворка, использующего внедрение зависимостей в качестве реализации принципа инверсии управления

![обложка доклада](./static/image/cover.png)
***Примечание* - В этом докладе, мы рассмотрим подход к построению современных фреймворков, использующих внедрение
зависимостей, чтобы сформировать понимание основных концепции инверсии контроля и способов кастомизации. Для того чтобы
ответить на все эти вопросы, мы будем писать приложение согласно поставленной бизнес-задаче. Однако для того, чтобы
написать красивый код, в процессе разработки у нас возникнет необходимость создать инфраструктуру, которая позволит
сделать наш код более гибким и будет соблюдать все правила SOLID. Именно в процессе написания и развития этой
инфраструктуры, которая будет подгоняться под нашу бизнес-задачу, у нас появится некий аналог современных фреймворков,
использующих внедрение зависимостей в качестве реализации принципа инверсии контроля.**

## 1. ВВЕДЕНИЕ

### ОПИСАНИЕ РЕШАЕМОЙ БИЗНЕС-ЗАДАЧИ
```
Компания "ЭкзаменаНет" разместила заказ на разработку сервиса, помогающего студентам списывать на экзаменах. На
данный момент аналитики компании находятся в процессе проработки требований, а от компании-подрядчика, которая
возьмется за выполнение данного заказа, требуется разработать простейший прототип приложения.

После многочасовых (и пока что бесполезных) совещаний аналитики решили, что для каждого студента и преподавателя
необходимо хранить следующие свойства:

    1. Уникальный идентификатор;
    2. Фамилию;
    3. Имя;
    4. Отчество;
    5. Дополнительные сведения.
    
Горе аналитики - не единственная беда компании-заказчика. Дело в том, что на текущий момент не выделен бюджет под
проработку сценариев, направленных на отвлечение внимания преподавателей, но уже сейчас можно сказать, что их будет
несколько. 

Формально требуется:
    1. Разработать объектную модель по требованиям заказчика; 
    2. Реализовать инфраструктуру приложения, способную гибко расширяться при появлении новых сценариев. 
```

### ОПИСАНИЕ ИНСТУРМЕНТАЛЬНЫХ СРЕДСТВ, ВЫБРАННЫХ ДЛЯ РЕШЕНИЯ ЗАДАЧИ

Разработку сервиса мы будем осуществлять с помощью языка программирования `JAVA`, а для сборки проекта использовать
`MAVEN`. Информацию о конфигурации и деталях проекта можно увидеть в [pom.xml](/exam-cheating-service/pom.xml) файле.
Отдельное внимание необходимо уделить сторонним зависимостям, которые мы будем использовать для решения задачи:
* `lombok` - это библиотека для сокращения кода в классах и расширения функциональности языка Java;
* `jsr250-api` - запрос спецификации Java, целью которого является разработка аннотаций для общих семантических 
концепций для платформы Java EE и Java SE (различные JSR используют аннотации для предоставления декларативного стиля
программирования);
* `reflections` - библиотека, расширяющая возможности стандартного Reflection API.

### ИНИЦИАЛИЗАЦИЯ ПРОЕКТА

Работу над реализацией проекта начнем с объявления объектной модели:

* Класс [Student](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/domain/model/Student.java) - модель студента;
* Класс [Teacher](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/domain/model/Teacher.java) - модель преподавателя;

Также давайте объявим класс [ExamCheatingService](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/service/ExamCheatingService.java),
который представляет собой сервис, помогающий студентам списывать на экзамене:

```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        // todo отвлечь преподавателя
        // todo разослать студентам ответы
    }

}

```

Таким образом, данный сервис должен сначала отвлечь внимание преподавателя, а затем разослать студентам ответы.

## 2. ПРОСТАЯ РЕАЛИЗАЦИЯ СЕРВИСА

На данном этапе нам необходимо заменить `todo` комментарии на некий алгоритм. Мы, конечно же, могли бы начать писать его
прямо в классе `ExamCheatingService`, однако нам необходимо писать код в соответствии с принципами SOLID, для того,
чтобы инкапсулировать ту логику, которая может быть использована в других местах нашего кода. Именно поэтому нам стоит
выделить две дополнительные сущности: `PrankerService` и `MessageSenderService`, так как в дальнейшем разработчики,
работающие вместе с нами, смогут их переиспользовать в своих целях.

> **ПОЧЕМУ НАМ ТАК ВАЖНЫ ПРИНЦИПЫ SOLID?**    
> * **S** - Single Responsibility - у класса должна быть только одна причина для изменения; 
> * **O** - Open Close Principle - программные сущности (классы, модули, функции) должны быть открыты для расширения, 
но закрыты для модификации;
> * **L** - Liskov Substitution - функции, которые используют базовый тип, должны иметь возможность использовать подтип
базового типа, не зная от этом;
> * **I** - Interface Segregation - программные сущности не должны зависеть от методов, которые они не используют;
> * **D** - Dependency Inversion - модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
> ___
> Принципы SOLID очень важная вещь, которая помогает нам делать свой код более гибким. Углубившись в историю разработки
> программного обеспечения, можно заметить, что раньше не было понятия `Continuous Delivery` и разработчики писали код
> один раз и навсегда, потому что не задумывали над тем, как написать код так, чтобы его потом были легко менять и
> переиспользовать.
> 
> Именно потому что современный мир очень динамичен, в котором никакая версия продукта не бывает конечной, у нас 
> появляются некие правила написания кода: 
> * Flexible - код должен быть гибким;
> * Reusable - должна быть возможность переиспользовать написанный код;
> * Readable - код должен быть читабельный, чтобы его было легко поддерживать и исправлять.

Давайте соответственно создадим интерфейс `PrankerService`, в котором у нас будет метод `prank(Teacher teacher)`,
отвечающий за отвлечение внимания преподавателя и его первую реализацию `DirectorCallPrankerService`, который будет
имитировать звонок преподавателю от вышестоящего руководства.
```java
/**
 * Интерфейс, определяющий общее поведение для всех сервисов, осуществляющих розыгрыш.
 *
 * @author Tyomych Tovkach.
 */
public interface PrankerService {

    /**
     * Метод осуществляющий розыгрыш преподавателя.
     *
     * @param teacher - преподаватель.
     */
    void prank(Teacher teacher);

}
```

```java
/**
 * Сервис, осуществляющий розыгрыш, имитирующий звонок от вышестоящего руководства.
 *
 * @author Tyomych Tovkach.
 */
public class DirectorCallPrankerService implements PrankerService {

    /**
     * Метод осуществляющий вызов преподавателю о лица вышестоящего руководства.
     *
     * @param teacher - преподаватель.
     */
    @Override
    public void prank(Teacher teacher) {
        System.out.printf("%s %s, быстро ко мне, иначе уволю!\n", teacher.getFirstName(), teacher.getPatronymic());
    }
}

```

Также давайте создадим интерфейс `MessageSenderService`, в котором у нас будет метод `send(List<Student> students)`,
отправляющий заданным студентам ответы и его первую реализацию 'PhoneNumberMessageSenderService', который будет
имитировать рассылку ответов на номера студентов.

```java
/**
 * Интерфейс, определяющий общее поведение для всех сервисов, осуществляющих рассылку сообщений.
 *
 * @author Tyomych Tovkach.
 */
public interface MessageSenderService {

    /**
     * Метод, осуществляющий рассылку сообщений студентам.
     *
     * @param students - студенты.
     */
    void send(List<Student> students);

}
```

```java
/**
 * Сервис, осуществляющий рассылку сообщений на телефонные номера.
 *
 * @author Tyomych Tovkach.
 */
public class PhoneNumberMessageSenderService implements MessageSenderService {

    /**
     * Метод осуществляющий рассылку сообщений на телефонные номера.
     *
     * @param students - студенты.
     */
    @Override
    public void send(List<Student> students) {
        for (Student student : students) {
            System.out.printf("Направляю на телефонный номер ответы студенту  %s\n", student.getLastName());
        }
    }
}
```

Ну и давайте, наконец, избавимся от `todo` комментариев в нашем классе `ExamCheatingService`, добавив в наш класс логику
предоставляемую `PrankerService` и `MessageSenderService`.

```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    private PrankerService prankerService = new DirectorCallPrankerService();
    private MessageSenderService messageSenderService = new PhoneNumberMessageSenderService();
    
    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        prankerService.prank(teacher);
        messageSenderService.send(students);
    }

}
```

Давайте создадим основной класс `Main`, отвечающий за запуск приложения, и попытаемся сымитировать вызов нашего сервиса, чем, заодно, и проверим его
работоспособность:

```java
/**
 * Главный класс приложения.
 *
 * @author Tyomych Tovkach
 */
public class Main {

    /**
     * Точка входа в приложение.
     *
     * @param args аргументы.
     */
    public static void main(String[] args) {
        ExamCheatingService examCheatingService = new ExamCheatingService();
        Teacher teacher = new Teacher();
        teacher.setFirstName("Алёна");
        teacher.setPatronymic("Владимировна");
        Student student = new Student();
        student.setLastName("Иванов");
        examCheatingService.start(teacher, List.of(student));
    }

}
```
```text
Алёна Владимировна, быстро ко мне, иначе уволю!
Направляю на телефонный номер ответы студенту  Иванов
```

Как мы можем увидеть по выводу приложение работает отлично: преподавателя мы отвлекли и студентам ответы разослали.
Несмотря на то, что мы старались писать код в соответствии со всем принципами SOLID, на мой взгляд в нашем коде есть ряд
проблем.

## 3. ПРОБЛЕМЫ ПРОСТЕЙШЕЙ РЕАЛИЗАЦИЯ СЕРВИСА

Давайте вернемся к нашему классу `ExamCheatingService` и постараемся, точно ли у него одна зона ответственности.
```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    private PrankerService prankerService = new DirectorCallPrankerService();
    private MessageSenderService messageSenderService = new PhoneNumberMessageSenderService();

    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        prankerService.prank(teacher);
        messageSenderService.send(students);
    }

}
```

В нашем классе есть два поля `prankerService` и `messageSenderService`, который создаются внутри него. Стоит отметить,
что `PrankerService` это интерфейс и, возможно, в будущем у нас появятся несколько имплементаций этого сервиса. Тогда
давайте ответим на вопрос: "Кто на данный момент принимает решения, что именно `DirectorCallPrankerService` должен быть
использован". Все верно, это решение принимает `ExamCheatingService`, что означает, что у него есть еще, как минимум,
одна зона ответственности.

Помимо этого, дополнительной зоной ответственности является необходимость понимать, как именно создавать
`DirectorCallPrankerService`: сегодня, чтобы его создать необходимо воспользоваться пустым конструктором, однако завтра
автор класса может принять решение о том, что необходимо переписать класс и воспользоваться дизайн-паттерном `Builder`,
сделав конструктор класса приватным. О чем, собственно говоря, должен будет знать наш `ExamCheatingService`, так как
именно он отвечает за создание этой имплементации.

Давайте также отметим, что еще одна зона ответственности нашего класса - умение настроить нашу имплементацию: на данный
момент, чтобы настроить `DirectorCallPrankerService` надо сделать ничего, однако, если автор класса решит добавить в
класс различные поля, которые необходимо будет проинициализировать с помощью сеттеров перед использованием класса, тогда
вся эта задача упадет на плечи `ExamCheatingService`.

Подведем промежуточные итоги: наш класс `ExamCheatingService` умеет выбрать правильную имплементацию `PrankerService`,
умеет создать и настроить `DirectorCallPrankerService`, то же самое с `MessageSenderService` и
`PhoneNumberMessageSenderService`. Однако, на самом деле, зон ответственности куда больше, так как по мере создания
новых имплементаций интерфейсов наш класс должен будут понимать, как их создать и настроить. 