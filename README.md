# Разработка фреймворка, использующего внедрение зависимостей в качестве реализации принципа инверсии управления

![обложка доклада](./static/image/cover.png)
***Примечание* - В этом докладе, мы рассмотрим подход к построению современных фреймворков, использующих внедрение
зависимостей, чтобы сформировать понимание основных концепции инверсии контроля и способов кастомизации. Для того чтобы
ответить на все эти вопросы, мы будем писать приложение согласно поставленной бизнес-задаче. Однако для того, чтобы
написать красивый код, в процессе разработки у нас возникнет необходимость создать инфраструктуру, которая позволит
сделать наш код более гибким и будет соблюдать все правила SOLID. Именно в процессе написания и развития этой
инфраструктуры, которая будет подгоняться под нашу бизнес-задачу, у нас появится некий аналог современных фреймворков,
использующих внедрение зависимостей в качестве реализации принципа инверсии контроля.**

## 1. ВВЕДЕНИЕ

### ОПИСАНИЕ РЕШАЕМОЙ БИЗНЕС-ЗАДАЧИ
```
Компания "ЭкзаменаНет" разместила заказ на разработку сервиса, помогающего студентам списывать на экзаменах. На
данный момент аналитики компании находятся в процессе проработки требований, а от компании-подрядчика, которая
возьмется за выполнение данного заказа, требуется разработать простейший прототип приложения.

После многочасовых (и пока что бесполезных) совещаний аналитики решили, что для каждого студента и преподавателя
необходимо хранить следующие свойства:

    1. Уникальный идентификатор;
    2. Фамилию;
    3. Имя;
    4. Отчество;
    5. Дополнительные сведения.
    
Горе аналитики - не единственная беда компании-заказчика. Дело в том, что на текущий момент не выделен бюджет под
проработку сценариев, направленных на отвлечение внимания преподавателей, но уже сейчас можно сказать, что их будет
несколько. 

Формально требуется:
    1. Разработать объектную модель по требованиям заказчика; 
    2. Реализовать инфраструктуру приложения, способную гибко расширяться при появлении новых сценариев. 
```

### ОПИСАНИЕ ИНСТУРМЕНТАЛЬНЫХ СРЕДСТВ, ВЫБРАННЫХ ДЛЯ РЕШЕНИЯ ЗАДАЧИ

Разработку сервиса мы будем осуществлять с помощью языка программирования `JAVA`, а для сборки проекта использовать
`MAVEN`. Информацию о конфигурации и деталях проекта можно увидеть в [pom.xml](/exam-cheating-service/pom.xml) файле.
Отдельное внимание необходимо уделить сторонним зависимостям, которые мы будем использовать для решения задачи:
* `lombok` - это библиотека для сокращения кода в классах и расширения функциональности языка Java;
* `jsr250-api` - запрос спецификации Java, целью которого является разработка аннотаций для общих семантических 
концепций для платформы Java EE и Java SE (различные JSR используют аннотации для предоставления декларативного стиля
программирования);
* `reflections` - библиотека, расширяющая возможности стандартного Reflection API.

### ИНИЦИАЛИЗАЦИЯ ПРОЕКТА

Работу над реализацией проекта начнем с объявления объектной модели:

* Класс [Student](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/domain/model/Student.java) - модель студента;
* Класс [Teacher](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/domain/model/Teacher.java) - модель преподавателя;

Также давайте объявим класс [ExamCheatingService](/exam-cheating-service/src/main/java/ru/tayviscon/knowledge/base/service/ExamCheatingService.java),
который представляет собой сервис, помогающий студентам списывать на экзамене:

```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        // todo отвлечь преподавателя
        // todo разослать студентам ответы
    }

}

```

Таким образом, данный сервис должен сначала отвлечь внимание преподавателя, а затем разослать студентам ответы.

## 2. ПРОСТАЯ РЕАЛИЗАЦИЯ СЕРВИСА

На данном этапе нам необходимо заменить `todo` комментарии на некий алгоритм. Мы, конечно же, могли бы начать писать его
прямо в классе `ExamCheatingService`, однако нам необходимо писать код в соответствии с принципами SOLID, для того,
чтобы инкапсулировать ту логику, которая может быть использована в других местах нашего кода. Именно поэтому нам стоит
выделить две дополнительные сущности: `PrankerService` и `MessageSenderService`, так как в дальнейшем разработчики,
работающие вместе с нами, смогут их переиспользовать в своих целях.

> **ПОЧЕМУ НАМ ТАК ВАЖНЫ ПРИНЦИПЫ SOLID?**    
> * **S** - Single Responsibility - у класса должна быть только одна причина для изменения; 
> * **O** - Open Close Principle - программные сущности (классы, модули, функции) должны быть открыты для расширения, 
но закрыты для модификации;
> * **L** - Liskov Substitution - функции, которые используют базовый тип, должны иметь возможность использовать подтип
базового типа, не зная от этом;
> * **I** - Interface Segregation - программные сущности не должны зависеть от методов, которые они не используют;
> * **D** - Dependency Inversion - модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
> ___
> Принципы SOLID очень важная вещь, которая помогает нам делать свой код более гибким. Углубившись в историю разработки
> программного обеспечения, можно заметить, что раньше не было понятия `Continuous Delivery` и разработчики писали код
> один раз и навсегда, потому что не задумывали над тем, как написать код так, чтобы его потом были легко менять и
> переиспользовать.
> 
> Именно потому что современный мир очень динамичен, в котором никакая версия продукта не бывает конечной, у нас 
> появляются некие правила написания кода: 
> * Flexible - код должен быть гибким;
> * Reusable - должна быть возможность переиспользовать написанный код;
> * Readable - код должен быть читабельный, чтобы его было легко поддерживать и исправлять.

Давайте соответственно создадим интерфейс `PrankerService`, в котором у нас будет метод `prank(Teacher teacher)`,
отвечающий за отвлечение внимания преподавателя и его первую реализацию `DirectorCallPrankerService`, который будет
имитировать звонок преподавателю от вышестоящего руководства.
```java
/**
 * Интерфейс, определяющий общее поведение для всех сервисов, осуществляющих розыгрыш.
 *
 * @author Tyomych Tovkach.
 */
public interface PrankerService {

    /**
     * Метод осуществляющий розыгрыш преподавателя.
     *
     * @param teacher - преподаватель.
     */
    void prank(Teacher teacher);

}
```

```java
/**
 * Сервис, осуществляющий розыгрыш, имитирующий звонок от вышестоящего руководства.
 *
 * @author Tyomych Tovkach.
 */
public class DirectorCallPrankerService implements PrankerService {

    /**
     * Метод осуществляющий вызов преподавателю о лица вышестоящего руководства.
     *
     * @param teacher - преподаватель.
     */
    @Override
    public void prank(Teacher teacher) {
        System.out.printf("%s %s, быстро ко мне, иначе уволю!\n", teacher.getFirstName(), teacher.getPatronymic());
    }
}

```

Также давайте создадим интерфейс `MessageSenderService`, в котором у нас будет метод `send(List<Student> students)`,
отправляющий заданным студентам ответы и его первую реализацию 'PhoneNumberMessageSenderService', который будет
имитировать рассылку ответов на номера студентов.

```java
/**
 * Интерфейс, определяющий общее поведение для всех сервисов, осуществляющих рассылку сообщений.
 *
 * @author Tyomych Tovkach.
 */
public interface MessageSenderService {

    /**
     * Метод, осуществляющий рассылку сообщений студентам.
     *
     * @param students - студенты.
     */
    void send(List<Student> students);

}
```

```java
/**
 * Сервис, осуществляющий рассылку сообщений на телефонные номера.
 *
 * @author Tyomych Tovkach.
 */
public class PhoneNumberMessageSenderService implements MessageSenderService {

    /**
     * Метод осуществляющий рассылку сообщений на телефонные номера.
     *
     * @param students - студенты.
     */
    @Override
    public void send(List<Student> students) {
        for (Student student : students) {
            System.out.printf("Направляю на телефонный номер ответы студенту  %s\n", student.getLastName());
        }
    }
}
```

Ну и давайте, наконец, избавимся от `todo` комментариев в нашем классе `ExamCheatingService`, добавив в наш класс логику
предоставляемую `PrankerService` и `MessageSenderService`.

```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    private PrankerService prankerService = new DirectorCallPrankerService();
    private MessageSenderService messageSenderService = new PhoneNumberMessageSenderService();
    
    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        prankerService.prank(teacher);
        messageSenderService.send(students);
    }

}
```

Давайте создадим основной класс `Main`, отвечающий за запуск приложения, и попытаемся сымитировать вызов нашего сервиса, чем, заодно, и проверим его
работоспособность:

```java
/**
 * Главный класс приложения.
 *
 * @author Tyomych Tovkach
 */
public class Main {

    /**
     * Точка входа в приложение.
     *
     * @param args аргументы.
     */
    public static void main(String[] args) {
        ExamCheatingService examCheatingService = new ExamCheatingService();
        Teacher teacher = new Teacher();
        teacher.setFirstName("Алёна");
        teacher.setPatronymic("Владимировна");
        Student student = new Student();
        student.setLastName("Иванов");
        examCheatingService.start(teacher, List.of(student));
    }

}
```
```text
Алёна Владимировна, быстро ко мне, иначе уволю!
Направляю на телефонный номер ответы студенту  Иванов
```

Как мы можем увидеть по выводу приложение работает отлично: преподавателя мы отвлекли и студентам ответы разослали.
Несмотря на то, что мы старались писать код в соответствии со всем принципами SOLID, на мой взгляд в нашем коде есть ряд
проблем.

## 3. ПРОБЛЕМЫ ПРОСТЕЙШЕЙ РЕАЛИЗАЦИЯ СЕРВИСА

Давайте вернемся к нашему классу `ExamCheatingService` и постараемся, точно ли у него одна зона ответственности.
```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    private PrankerService prankerService = new DirectorCallPrankerService();
    private MessageSenderService messageSenderService = new PhoneNumberMessageSenderService();

    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        prankerService.prank(teacher);
        messageSenderService.send(students);
    }

}
```

В нашем классе есть два поля `prankerService` и `messageSenderService`, который создаются внутри него. Стоит отметить,
что `PrankerService` это интерфейс и, возможно, в будущем у нас появятся несколько имплементаций этого сервиса. Тогда
давайте ответим на вопрос: "Кто на данный момент принимает решения, что именно `DirectorCallPrankerService` должен быть
использован". Все верно, это решение принимает `ExamCheatingService`, что означает, что у него есть еще, как минимум,
одна зона ответственности.

Помимо этого, дополнительной зоной ответственности является необходимость понимать, как именно создавать
`DirectorCallPrankerService`: сегодня, чтобы его создать необходимо воспользоваться пустым конструктором, однако завтра
автор класса может принять решение о том, что необходимо переписать класс и воспользоваться дизайн-паттерном `Builder`,
сделав конструктор класса приватным. О чем, собственно говоря, должен будет знать наш `ExamCheatingService`, так как
именно он отвечает за создание этой имплементации.

Давайте также отметим, что еще одна зона ответственности нашего класса - умение настроить нашу имплементацию: на данный
момент, чтобы настроить `DirectorCallPrankerService` надо сделать ничего, однако, если автор класса решит добавить в
класс различные поля, которые необходимо будет проинициализировать с помощью сеттеров перед использованием класса, тогда
вся эта задача упадет на плечи `ExamCheatingService`.

Подведем промежуточные итоги: наш класс `ExamCheatingService` умеет выбрать правильную имплементацию `PrankerService`,
умеет создать и настроить `DirectorCallPrankerService`, то же самое с `MessageSenderService` и
`PhoneNumberMessageSenderService`. Однако, на самом деле, зон ответственности куда больше, так как по мере создания
новых имплементаций интерфейсов наш класс должен будут понимать, как их создать и настроить. 

## 4. ПЕРЕВОДИМ ИНФРАСТРУКТУРУ НА ФАБРИКИ

***Примечание* - В этой главе мы постараемся ответить на вопрос: "А кто тогда должен решать, какая имплементация нужна?"**

### 4.1 ЭКСКУРС В ИСТОРИЮ ЭВОЛЮЦИИ ОБЪЕКТНО-ОРИЕНТИРОВАННОГО ПРОГРАММИРОВАНИЯ
Во времена появления языка программирования Java, люде вообще не совсем понимали принципы объектно-ориентированного
программирования, так как опыт, который был ранее накоплен, был более процедуральным и поэтому нередко можно было
встретить Java-приложения, написанные полностью при помощи статических методов. Но ближе к началу 2000-ых люди, наконец,
поняли, что Java это про объекты, которые можно создавать, настраивать, переиспользовать, передавать их в качестве
параметров, инкапсулировать в них логику. И тогда программисты начали активно создавать объекты с помощью `new`, при
этом не задумываясь о последствиях, так как в те времена не было вообще таких понятий, как *версионирование* и 
*continuous delivery*. Однако уже вскоре программисты поняли, что просто написать код намного менее важно, чем сделать
его таким, чтобы его потом можно было легко развивать. Именно в это время появился стильный, модный, молодежный паттерн
`Фабрика`, который начали писать практически для всех объектов. В рамках решаемой нами задачи, у нас должны бы были
появиться как минимум `PrankerServiceFactory`, `MessageSenderServiceFactory`, `ExamCheatingServiceFactory`. Но и в этом
решении была проблема, так как фабрик становилось огромное множество, их надо было тоже уметь настраивать и по итогу
оказалось, что мы просто сместили говнокод из одного места в другое.

> В начале 2000-ых годов был очень популярен мем: *Хотел использовать Java и теперь у меня одна сплошная `ProblemFactory`*:)

После этого объектно-ориентированное программирование перешло в следующий этап эволюции и во многие проектах начали
писать инфраструктуру, ядром которой являлся некий класс `ObjectFactory`. Этот класс должен был быть `Singleton` и
должен был быть доступен из любой точки приложения, чтобы разработчик мог попросить у него создать объект какого-либо типа. 

### 4.2 ПИШЕМ СВОЮ ФАБРИКУ ОБЪЕКТОВ
`ObjectFactory` это еще далеко не инверсия контроля, однако, чтобы приблизиться к пониманию того, как реализованы
современные `Dependency Injection` фреймворки необходимо написать собственную фабрику объектов и проанализировать
недостатки этого инфраструктурного решения.

Начнем свою реализацию с написания класса `ObjectFactory`, который должен быть реализован, согласно паттерну `Singleton`
и должен иметь возможность создавать объекты, в зависимости от запрашиваемого класса.

```java
/**
 * Фабрика объектов.
 *
 * @author Tyomych Tovkach.
 */
public class ObjectFactory {

    /**
     * Экземпляр класса ObjectFactory.
     */
    private static ObjectFactory instance = new ObjectFactory();

    /**
     * Метод получения экземпляра класса ObjectFactory.
     *
     * @return экземпляр класса ObjectFactory.
     */
    public static ObjectFactory getInstance() {
        return instance;
    }

    /**
     * Конструктор класса.
     */
    private ObjectFactory() {
    }

    /**
     * Метод, создающий объекты в зависимости от типа класса, пришедшего в параметре.
     *
     * @param type класс.
     * @param <T>  тип класса.
     * @return объект типа T.
     */
    public <T> T createObject(Class<T> type) {
        //TODO: написать логику метода.
    }

}
```

Давайте теперь посмотри, как этот класс будет использоваться, на примере нашего `ExamCheatingService`.
 ```java
/**
 * Сервис, помогающий студентам списывать на экзамене.
 *
 * @author Tyomych Tovkach
 */
public class ExamCheatingService {

    private PrankerService prankerService
        = ObjectFactory.getInstance().createObject(PrankerService.class);
    
    private MessageSenderService messageSenderService
        = ObjectFactory.getInstance().createObject(MessageSenderService.class);

    /**
     * Основной метод сервиса.
     *
     * @param teacher  преподаватель, которого необходимо отвлечь.
     * @param students студенты, которым необходимо разослать ответы.
     */
    public void start(Teacher teacher, List<Student> students) {
        prankerService.prank(teacher);
        messageSenderService.send(students);
    }

}
```

Как мы можем увидеть, наш код стал чище, так как теперь наш `ExamCheatingService` вообще ничего не знает ни про
`PrankerService`, ни про `MessageSenderService`, а знает лишь то, что они ему нужны, но логика по выбору конкретной
имплементации интерфейса, ее созданию и настройке скрыта от сервиса внутри фабрики объектов.

> [!NOTE]
> **Стоит отметить, что в большинстве случаев, в параметре метода `createObject` будет приходить интерфейс, однако лучше
> предусмотреть логику, когда разработчик сможет указать конкретный класс.**

Давайте вернемся к реализации нашего метода `createObject` в классе `ObjectFactory`, где сделаем проверку:
Если пришедший в параметре метода `type` является интерфейсом, то его необходимо заменить соответствующей имплементацией.
Однако давайте задумаемся над тем, откуда `ObjectFactory` будет узнавать, какую реализацию интерфейса необходимо
создавать. Для реализации этой функциональности, согласно `Single Responsibility` принципу, предлагается выделить
интерфейс `Config`. Классы имплементирующее этот интерфейс должны будут, на основании переданного в параметре интерфейса,
возвращать его реализацию.

```java
/**
 * Интерфейс конфигурации приложения.
 *
 * @author Tyomych Tovkach.
 */
public interface Config {

    /**
     * Метод получения класса, который реализует заданный интерфейс.
     *
     * @param ifc интерфейс.
     * @param <T> тип интерфейса.
     * @return класс, реализующий интерфейс.
     */
    <T> Class<? extends T> getImplClass(Class<T> ifc);

}
```

Также сразу напишем его реализацию `JavaConfig`, которая будет конфигурировать приложение на основании Java кода.
> [!NOTE]
> **Стоит отметить, что в большинстве случаев имплементация у интерфейсов будет одна, однако лучше предусмотреть
> возможность того, что у одного интерфейса может быть несколько имплементаций.** Давайте для начала исходит из
> предположения, что у одного интерфейса - одна имплементация, но лишь для того, чтобы в дальнейшем это предположение
> нарушить и увидеть, как у нас изменится наш метод `getImplClass`.

Для реализации класса `JavaConfig` нам понадобится `Reflection API` и мы активно будем использовать, подключенную нами
библиотеку:

```xml
<dependency>
    <groupId>org.reflections</groupId>
    <artifactId>reflections</artifactId>
    <version>0.10.2</version>
</dependency>
```

Нам понадобиться класс `org.reflections.Reflections`, который расширяет возможности, существующего в Java,
`Reflection API`. Для создания объекта этого класса нам необходимо передать в конструкторе пакет, с которого необходимо
начать сканирование. Тогда в методе `getImplClass` нам необходимо будет получить все подтипы в иерархии переданного
интерфейса и если их количество не равно единице, то выбросить соответствующее исключение. Если же у интерфейса
существует лишь одна имплементация, то ее необходимо вернуть. Давайте, наконец, посмотрим на наш класс `JavaConfig`:

```java
/**
 * Конфигурации приложения на основании Java-кода.
 *
 * @author Tyomych Tovkach.
 */
public class JavaConfig implements Config {

    private Reflections scanner;

    /**
     * Конструктор класса.
     *
     * @param packageToScan пакет, с которого необходимо начинать сканирование.
     */
    public JavaConfig(String packageToScan) {
        this.scanner = new Reflections(packageToScan);
    }

    /**
     * Метод получения класса, который реализует заданный интерфейс.
     *
     * @param ifc интерфейс.
     * @param <T> тип интерфейса.
     * @return класс, реализующий интерфейс.
     */
    @Override
    public <T> Class<? extends T> getImplClass(Class<T> ifc) {
        Set<Class<? extends T>> classes = scanner.getSubTypesOf(ifc);
        if (classes.size() != 1) {
            throw new RuntimeException(ifc + " has zero or more than one implementations");
        }
        return classes.iterator().next();
    }
}
```